/*
 * This script exposes a "/status" endpoint that returns Prometheus metrics that can be scraped.
 * It will be reachable under "<ip>/script/<id>/metrics". Id will be 1 if this is your first script.
 *
 * Example Prometheus config:
 *
 * scrape_configs:
 *   - job_name: 'shelly'
 *     metrics_path: /script/1/metrics
 *     static_configs:
 *       - targets: ['<ip>']
 *
 * Replace <ip> with the ip address of the device and adjust the script id if needed.
 *
 * If you use Grafana to display metrics scraped, you can give a try to the example dashboard in prometheus-grafana-example-dashboard.json
 * available via the url https://raw.githubusercontent.com/ALLTERCO/shelly-script-examples/main/prometheus-grafana-example-dashboard.json
 *
 * Note: This script assumes you have one switch, but you can configure that in the Configuration section
 */
// ---------------------------------------------------------------------------------------------------------------------
// Configuration (you can change / adapt here)
// ---------------------------------------------------------------------------------------------------------------------

// Prefix added to all metrics name
const metric_prefix = "shelly_"
// url of metrics. will be used for the last part of "<ip>/script/<id>/<url>"
//    where ip = your plug ip/hostname; id the script id or number (1 if this is the first); url the value below
const url = "metrics"

// List of internal switch to monitor using the shelly's id naming scheme in the form of switch:<id> (ex switch:0)
const fan1 = "boolean:200"
const fan2 = "boolean:201"
const status = "enum:200"
const temperature = "number:200"

// ---------------------------------------------------------------------------------------------------------------------
// Prometheus exporter
// ---------------------------------------------------------------------------------------------------------------------

const TYPE_GAUGE = "gauge"
const TYPE_COUNTER = "counter"

var info = Shelly.getDeviceInfo();

function promLabel(label, value) {
    return [label, "=", '"', value, '"'].join("");
}

// Will be added to every metrics
var defaultLabels = [
    ["name", info.name],
    ["id", info.id],
    ["mac", info.mac],
    ["app", info.app]
]
    .map(function (data) {
        return promLabel(data[0], data[1]);
    });

/**
 *  Generate one metric output with all the shenanigans around it
 * @param name The name of the metrics (Will be prefixed by metric_prefix value)
 * @param type One of the TYPE_* of metrics. Usually Counter, Gauge, Histogram (not supported yes)
 * @param specificLabels Array of labels generated by promLabel() specific to this metric.
 * @param description An Human description of the metric
 * @param value The actual metric numeric value
 * @returns {string} The metric string to include in final response
 */
function printPrometheusMetric(name, type, specificLabels, description, value) {
    return [
        "# HELP ", metric_prefix, name, " ", description, "\n",
        "# HELP ", metric_prefix, name, " ", type, "\n",
        metric_prefix, name, "{", defaultLabels.join(","), specificLabels.length > 0 ? "," : "", specificLabels.join(","), "}", " ", value, "\n\n"
    ].join("");
}

/**
 * HTTP handler that will be called when the url will be accessed
 * @param request
 * @param response
 */
function httpServerHandler(request, response) {
    response.body = [
        generateMetricsForSystem(),
        generateMetricsForFan1(),
        generateMetricsForFan2(),
        generateMetricsForGHStatus(),
        generateMetricsForTemperature(),
    ].join("")
    response.code = 200;
    response.headers = [['Content-Type', 'text/plain; version=0.0.4']]
    response.send();
}

/**
 * Generate metrics for the system part
 * @returns {string}
 */
function generateMetricsForSystem() {
    const sys = Shelly.getComponentStatus("sys")
    return [
        printPrometheusMetric("uptime_seconds", TYPE_COUNTER, [], "power level in watts", sys.uptime),
        printPrometheusMetric("ram_size_bytes", TYPE_GAUGE, [], "Internal board RAM size in bytes", sys.ram_size),
        printPrometheusMetric("ram_free_bytes", TYPE_GAUGE, [], "Internal board free RAM size in bytes", sys.ram_free)
    ].join("")
}

function generateMetricsForFan1() {
    const vc = Shelly.getComponentStatus(fan1);
    return printPrometheusMetric("greenhouse_fan1_output", TYPE_GAUGE, [promLabel("boolean", vc.id)], "Fan 1 output", Number(vc.value));
}

function generateMetricsForFan2() {
    const vc = Shelly.getComponentStatus(fan2);
    return printPrometheusMetric("greenhouse_fan2_output", TYPE_GAUGE, [promLabel("boolean", vc.id)], "Fan 2 output", Number(vc.value));
}

function generateMetricsForGHStatus() {
    const statusMap = {
        "normal": 0,
        "warning": 1,
        "alert": 2,
        "danger": 3
    }
    const vc = Shelly.getComponentStatus(status);
    return printPrometheusMetric("greenhouse_status", TYPE_GAUGE, [promLabel("enum", vc.id)], "Greenhouse status", statusMap[vc.value]);
}

function generateMetricsForTemperature() {
    const vc = Shelly.getComponentStatus(temperature);
    return printPrometheusMetric("greenhouse_temperature", TYPE_GAUGE, [promLabel("number", vc.id)], "Temperature", vc.value);
}

HTTPServer.registerEndpoint(url, httpServerHandler);